# project_pathplanning
Филитов Михаил, 164 группа, Pathplanning

Актуальность проблемы:
-----------------------

Все больше и больше сложной, опасной для жизни работы мы можем доверить роботам, тем самым избежав человеческих жертв, но чтобы робот корректно справился с поставленной задачей, он должен верно сконструировать безопасный и кротчайший путь. Таким образом проблема проложения пути для робота является насущной и крайне важной. Для нахождения путей данные роботы уже используются в быту (работы-пылесосы), в науке(лунаходы).

Будет использоваться:
---------------------

Операционная система ubuntu, поскольку она позволяет более удобно работать с кодом и с библиотеками.
В качестве IDE будет использоваться QT Creator, поскольку он является кроссплатформенным, поддерживает различные компиляторы, а также поддерживает системы контроля версий, в том числе Git.
Также будет использоваться TinyXML, поскольку в качестве исходного кода программа будет принимать XML файл с разметкой карты, и как разультат выдавать файл в том же формате, который впоследствии будет обрабатываться роботом. Он удобен, поскольку поддерживается с++.
Для решения поставленной задачи предлагается разбить плоскость на квадраты (большие в областях, где нет препятствий, меленькие в областях, где рядом есть препятствия) и строить маршрут в  графе, где вершинами выступают узлы сетки, а ребрами - ребра квадратов, в качестве весов ребер можно выбрать, к примеру, расстояние между точками вершинами на плоскости. Также, чтобы не учитывать размер робота, можно увеличить размеры препятствий, тогда можно будет считать робота точкой.Также будем делать робота круглым с возможностью поворота на месте, чтобы облегчить планирование траектории и избежать учета траектории поворота.

Архитектура продукта в целом:
------------------
Используется объектно оринтированная модель программирования. Реализован алгоритм Дейкстры и на основе его работает A*, для чего некоторые функции были переопределены, например, вес эвристики в Дейкстре считается за 0, а в A* функция переопределена и возвращает значение в зависимости от выбранной эвристики. В проекте присутствует разделение файлов на заголовки и сами функции для удобства использования и облегчения понимания сторонним человеком сути программы.Для работы с XML файлами используется библиотека tinyXML, поскольку она относительно небольшая и легкая, а также обладает всеми необходимыми инструментами для работы с данным типом файлов.


План:
------

Январь - Февраль: Функционал A* реализован в программном коде, все опции (разрешенные движения, вес эвристики, breaking ties стратегии и пр.) hard-coded, проект компилируется и корректно работает (выходной файл требуемого формата).

Февраль - Март:  Функционал A* реализован в программном коде, поддерживаются различные опции поиска (вес эвристики, breaking ties стратегии, разрешенные движения и пр.), проект компилируется и корректно работает (выходной файл требуемого формата).

Март - Апрель: Функционал A*, Theta* и JPS реализован в программном коде с использованием грамотной иерархии классов (наследование, не дублирование основного функционала и пр.), поддерживаются различные опции поиска (вес эвристики, breaking ties стратегии, разрешенные движения и пр.), проект компилируется и корректно работает (выходной файл требуемого формата).

Апрель - Май:  Программный код встроен в ROS и используется для планирования траектории TurtleBot (симуляция в Gazebo).

Инструкция по компиляции:
--------------------------
Можно компилировать, используя cmake или qmake. Файл CMakeLists и .pro файлы предоставленны. Для 
запуска можно использовать Qt creator, для этого нужно запустить QT Creator и в нем открыть .pro файл, остальные файлы подключатся автоматически. Чтобы запустить программу, использу cmake, нужно зайти в папку cpp_files, используя терминал, запустить команду cmake CMakeLists.txt, создастся файл CMakeFiles, далее необходимо ввести команду make, после ее выполнения появится файл ASearch, который надо запустить, как обычный исполняемый файл, то есть ./Asearch file.xml в качестве аргумента коммандной строки передается путь до входного  xml файла. После чего в этой же папке появится файл с логом, в котором будет результат выполненной программы. Значение полей описаны ниже и в примерах. Взаимодействие с программой происходит через командную строку, чтобы получить данные о пути необходимо передать xml
файл в качестве аргумента при запуске. Формат входного и выходного файла можно увидеть в примерах, описние дано ниже.
В проекте используется 11 стандарт языка c++. 

Пример входного и выходного файла:
----------------------------------
[Пример](https://github.com/lll-phill-lll/Path_planning/tree/master/xml_examples)

Реализованная функциональность:
------------------------------

Полностью работающий алгоритм А* и Дейкстра, поддерживаются настроечные опции: все описанные
метрики, cutcorners, allowsqeeze, breaking ties, вес эвристики. 


Состав входного файла XML:
------------------
Файл представляет из себя описание поля с препятствиями и формат используемого алгоритма поиска пути.

- \<map\> - содержит описание карты местности.
  - \<width\> - задает ширину поля в условных единицах.
  - \<height\> - задает высоту поля в условных единицах.
  - \<cellsize\> - задает размер условнх единиц.
  - \<startx\>, \<starty\>, \<finishx\>, \<finishy\> - задают соответственно координаты начала движения и конечной точки, координаты принимают только неотрицательные значения.
  - \<grid\> - само поле, заданное матрицей из 0 и 1.
    - \<row\> - строки поля со значениями 0 - свободно, 1 - препятствие. В каждом row количество 0 и 1 соответствует знаечнию width, количество row соответствует знаечнию height.

- \<algorithm\> - параметры применяемого алгоритма далее идут параметры.
  -  \<searchtype\> - выбрать алгоритм (dijkstra, astar, theta, gps).
  - \<metrictype\> - используемая метрика для определния кратчайшего расстояния (euclid, diagonal, manhattan, chebyshev).
    - euclid: ` ``` $d(a, b) = \sqrt{(a_1 - b_1)^2 + \dots + (a_n - b_n)^2}$ ```.
    - diagonal: ```  $d(a, b) = min(|a_1 - b_1|, |a_2 - b_2| + ||a_1 - b_1| - |a_2 - b_2||)$```. 
    -  manhattan: ``` $d(a, b) = \sum\limits^{n}_{i = 1}(a_i - b_i)$ ```.
    -  chebyshev: ``` $d(a, b) = \max(a_i - b_i) ```$
  - \<breakingties\> -критерий второго уровня выбора элемента. Если F значения равны, то будет выбираться или с наименьшим g значением g_min или с наибольшим g_max.
  - \<hweight\> вес эвристики.
  - \<allowdiagonal\> - разрешено ли ходить по диагонали (Допустимые значения true\false).
  - \<cutcorners\> - можно ли угол препятствия обходить по диагонали (Допустимые значения true\false).
  - \<allowsqueeze\> если два препятствия касаются углами, можно ли между ними пройти (если cutcorners = 0, то эта опция выполняться не будет), (Допустимые значения true\false).
- \<options\>
  - \<loglevel\> - каким образом завершился алгоритм.
    - 0: нет лога.
    - 0.5: xml summary.
    - 1: xml summary + hplevel, lplevel.
    - 1.5: то, что при 1, только еще содержимое closed и open на последнем шаге.
    - 2: то, что при 1,5, но содержимое open, closed выдается на каждом шаге, причем из open 
    выводятся вершины в порядке увеличения значения f.
  -  \<logpath\> - имя каталога, куда будет писаться лог.
  -  \<logfilename\> - имя файла, куда будет писаться лог.
  
  

Состав выходного файла XML:
------------------
Формат такой же, только добавляется еше один раздел на том же уровне, что и options:
- \<log\> - описание проделанной работы.
  - \<mapfilename\> имя входного файла.
  - \<summary numberofsteps="0" nodescreated="0" length="0" length_scaled="0" time="0.000000"\> - сколько всего было сделано шагов при работе алгоритма, сколько создано вершин в графе, длина маршрута в условных единицах, длина маршрута в единицах cellsize, время работы алгоритма соответственно.
  - \<path\> - сам маршрут, или path NOT found, если маршрут не найден.
  - \<lplevel> - запись пути, представляющая из себя последовательность координат точек пути.
  - \<hplevel\> - запись пути, представляющая из себя последовательность участков, по которым надо идти не сворачивая. Указывается координата начала отрезка и конец, а также длина отрезка. 

Заключение:
-----------
После завершения проекта имеется программа, которая может искать оптимальный маршрут, причем маршрут может быть подстроен под конкретные задачи за счет большого количества настроечных опций. В том числе можно влиять на скорость вычисления маршрута, путем увеличения веса эвристики в A*, в таком случае будет некоторая потеря в оптимальности пути, он выйдет длиннее, но скорость работы программы увеличивается на порядки, в некоторых ситуациях это может сыграть важную роль. 
В качестве входных и выходных данных используется XML файл, что означает простоту внедрения этого проекта, поскольку несколько программ могут обмениваться XML файлами и таким образом взаимодействовать друг с другом без необходимости дополнительной адаптации друг к другу.   

Реализованы алгоритмы A* и Дейкстра. Theta* и JPS не выполнены, поскольку из-за нехватки знаний пришлось несколько раз полностью переделывать проект, на что ушло много времени. Я планирую доделать их уже за рамками проекта. Дейкстра и A* с велом эвристики 1 выдают длину пути такую же, как и baseline, время работы несколько больше, что связано с не самым лучшим выбором контейнеров для open и close. При большом весе эвристики есть расхождения с baseline, что является допустимым отклонением. 

В ходе работы над проектом я узнал много нового. Научился работать с классами и понял основы объектно ориентированного программирования. Также я осознал важность правильного оформления кода, когда проекта состоит из большого количества кода очень удобно его организовать по разным файлам и выносить заголовочную часть отдельно. Помимо этого я на собственном опыте убедился, насколько важно следить за оптимальностью алгоритма и правильностью выбора контейнеров, на больших картах подобные ошибки могут выливаться в замедление работы программы в несколько раз. Я разобрался в новых для меня алгоритмах A* и Theta*, была необходимость изучать статьи и научные работы по ним, что тоже является полезным умением. 

